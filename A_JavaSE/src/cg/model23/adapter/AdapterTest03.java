package cg.model23.adapter;

public class AdapterTest03 {

	public static void main(String[] args) {



		//接口适配器  Ps2 接口 使用 usb 接口
		/*
		 * 接口适配器模式
			　　原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。
			　　当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，
			如果我们直接实现接口，那么我们要对所有的方法进行实现，
			哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，
			不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，
			这时我们可以使用一个抽象类作为中间件，
			即适配器，用这个抽象类实现接口，
			而在抽象类中所有的方法都进行置空，
			那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。
		 */
		A a = (A) new Ashili();
		a.a();
		a.d();


	}
}

interface A {
	void a();
	void b();
	void c();
	void d();
	void e();
	void f();
}

abstract class Adapter3 implements A {
	public void a(){}
	public void b(){}
	public void c(){}
	public void d(){}
	public void e(){}
	public void f(){}

}


class Ashili extends Adapter3 {
	public void a(){
		System.out.println("实现A方法被调用");
	}
	public void d(){
		System.out.println("实现d方法被调用");
	}
}
/*
 * 类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：
 
　　（1）想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。
 
　　（2）我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。
 
　　以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。
 
接口适配器使用场景：
 
　　（1）想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

*/