package cg.model23.meiator;

public interface Mediator {


    /**
     * 同事对象在自身改变的时候来通知调停者方法
     * 让调停者去负责相应的与其他同事对象的交互
     */
    public void changed(Colleague c);
    
}
    /*
     * 调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。
     * 从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。
     * 从而保证这些相互作用可以彼此独立地变化。

为什么需要调停者
　　如下图所示，这个示意图中有大量的对象，这些对象既会影响别的对象，又会被别的对象所影响，因此常常叫做同事(Colleague)对象。
	这些同事对象通过彼此的相互作用形成系统的行为。
	从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。
	这就是过度耦合的系统。


　　通过引入调停者对象(Mediator)，可以将系统的网状结构变成以中介者为中心的星形结构，如下图所示。在这个星形结构中，同事对象不再通过直接的联系与另一个对象发生相互作用；
	相反的，它通过调停者对象与另一个对象发生相互作用。调停者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。

　	一个好的面向对象的设计可以使对象之间增加协作性(Collaboration)，减少耦合度(Couping)。一个深思熟虑的设计会把一个系统分解为一群相互协作的同事对象，然后给每一个同事对象以独特的责任，
	恰当的配置它们之间的协作关系，使它们可以在一起工作。

如果没有主板
　　大家都知道，电脑里面各个配件之间的交互，主要是通过主板来完成的。
	如果电脑里面没有了主板，那么各个配件之间就必须自行相互交互，以互相传送数据。而且由于各个配件的接口不同，相互之间交互时，还必须把数据接口进行转换才能匹配上。

　　所幸是有了主板，各个配件的交互完全通过主板来完成，每个配件都只需要和主板交互，而主板知道如何跟所有的配件打交道，这样就简单多了。




调停者模式的结构

　　调停者模式的示意性类图如下所示：


　　调停者模式包括以下角色：

　　●　　抽象调停者(Mediator)角色：定义出同事对象到调停者对象的接口，其中主要方法是一个（或多个）事件方法。

　　●　　具体调停者(ConcreteMediator)角色：实现了抽象调停者所声明的事件方法。具体调停者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。

　　●　　抽象同事类(Colleague)角色：定义出调停者到同事对象的接口。同事对象只知道调停者而不知道其余的同事对象。

　　●　　具体同事类(ConcreteColleague)角色：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的调停者通信，调停者会负责与其他的同事交互。


原文：https://blog.csdn.net/u011225629/article/details/47721921 

使用电脑来看电影
　　在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程：

　　（1）首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。

　　（2）主板去得到光驱的数据，把这些数据交给CPU进行分析处理。

　　（3）CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。

　　（4）主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音。

　　要使用调停者模式来实现示例，那就要区分出同事对象和调停者对象。很明显，主板是调停者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。
--------------------- 
作者：Simon丶Ma 
来源：CSDN 
原文：https://blog.csdn.net/u011225629/article/details/47721921 
版权声明：本文为博主原创文章，转载请附上博文链接！
     */


