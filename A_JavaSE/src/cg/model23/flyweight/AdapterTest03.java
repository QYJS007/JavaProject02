package cg.model23.flyweight;

public class AdapterTest03 {

	public static void main(String[] args) {



		//接口适配?  Ps2 接口 使用 usb 接口
		/*
		 * 接口适配器模?
			??原理：?过抽象类来实现适配，这种?配稍别于上面所述的适配?
			??当存在这样一个接口，其中定义了N多的方法，?我们现在却只想使用其中的一个到几个方法?
			如果我们直接实现接口，那么我们要对所有的方法进行实现?
			哪?我们仅仅是对不?要的方法进行置空（只写一对大括号?
			不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，
			这时我们可以使用?个抽象类作为中间件，
			即?配器，用这个抽象类实现接口?
			而在抽象类中?有的方法都进行置空，
			那么我们在创建抽象类的继承类，?且重写我们?要使用的那几个方法即可??
		 */
		A a = (A) new Ashili();
		a.a();
		a.d();


	}
}

interface A {
	void a();
	void b();
	void c();
	void d();
	void e();
	void f();
}

abstract class Adapter3 implements A {
	public void a(){}
	public void b(){}
	public void c(){}
	public void d(){}
	public void e(){}
	public void f(){}

}


class Ashili extends Adapter3 {
	public void a(){
		System.out.println("实现A方法被调?");
	}
	public void d(){
		System.out.println("实现d方法被调?");
	}
}
/*
 * 类?配器与对象适配器的使用场景?致，仅仅是实现手段稍有区别，二?主要用于如下场景：
 
???1）想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个?配器就能间接去访问这个类中的方法??
 
???2）我们有?个类，想将其设计为可重用的类（可被多处访问），我们可以创建?配器来将这个类来?配其他没有提供合?接口的类??
 
??以上两个场景其实就是从两个角度来描述?类问题，那就是要访问的方法不在合适的接口里，?个从接口出发（被访问），?个从访问出发（主动访问）?
 
接口适配器使用场景：
 
???1）想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的?有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来?过重写想用的方法的方式来实现?这个抽象类就是适配器??

*/